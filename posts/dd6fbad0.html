<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java编程之Java高并发核心编程学习之第1-4章IO基础 | AI-X</title><meta name="author" content="AI-X"><meta name="copyright" content="AI-X"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="article">
<meta property="og:title" content="Java编程之Java高并发核心编程学习之第1-4章IO基础">
<meta property="og:url" content="https://www.ai-x.co.uk/posts/dd6fbad0.html">
<meta property="og:site_name" content="AI-X">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.ai-x.co.uk/img/cover-java-high-concurrent.jpg">
<meta property="article:published_time" content="2024-12-27T10:08:07.000Z">
<meta property="article:modified_time" content="2025-09-21T18:54:57.166Z">
<meta property="article:author" content="AI-X">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="NIO">
<meta property="article:tag" content="Netty">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="ZooKeeper">
<meta property="article:tag" content="AIO">
<meta property="article:tag" content="Feign">
<meta property="article:tag" content="Nginx">
<meta property="article:tag" content="LVS">
<meta property="article:tag" content="高并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.ai-x.co.uk/img/cover-java-high-concurrent.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.ai-x.co.uk/posts/dd6fbad0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'pub-6067535447489483',
  enable_page_level_ads: 'true'
});</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: AI-X","link":"链接: ","source":"来源: AI-X","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java编程之Java高并发核心编程学习之第1-4章IO基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-21 18:54:57',
  isShuoshuo: false
}</script><link rel="stylesheet" href="/css/customall.css"><link rel="stylesheet" href="/css/modify.css"><link rel="stylesheet" href="https://ai.tianli0.top/static/public/tianli_gpt.min.css"><script src="/js/echarts.min.js"></script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (true) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="web_bg" style="background-image: url(/img/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/aixlog.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">391</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-camera-retro"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 交流</span></a></div><div class="menus_item"><a class="site-page" href="/Timeline/"><i class="fa-fw fa fa-paper-plane"></i><span> 留痕</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/cover-java-high-concurrent.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/aixlog.png" alt="Logo"><span class="site-name">AI-X</span></a><a class="nav-page-title" href="/"><span class="site-name">Java编程之Java高并发核心编程学习之第1-4章IO基础</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/charts/"><i class="fa-fw fas fa-camera-retro"></i><span> 统计</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comments"></i><span> 交流</span></a></div><div class="menus_item"><a class="site-page" href="/Timeline/"><i class="fa-fw fa fa-paper-plane"></i><span> 留痕</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java编程之Java高并发核心编程学习之第1-4章IO基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-27T10:08:07.000Z" title="发表于 2024-12-27 10:08:07">2024-12-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-21T18:54:57.166Z" title="更新于 2025-09-21 18:54:57">2025-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI-X%E5%BC%80%E5%8F%91/">AI-X开发</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/">编程/开发技术</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">16k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>49分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id data-flag-title><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img" style="background-image: url(/img/cover-java-high-concurrent.jpg);"></div><article class="post-content" id="article-container"><blockquote>
<p>内容来自于《Java高并发核心编程》卷1：NIO、Netty、Redis、ZooKeeper</p>
</blockquote>
<h1 id="《Java高并发核心编程》卷1：内容介绍"><a href="#《Java高并发核心编程》卷1：内容介绍" class="headerlink" title="《Java高并发核心编程》卷1：内容介绍"></a>《Java高并发核心编程》卷1：内容介绍</h1><p>第1～4章从操作系统的底层原理开始，浅显易懂地揭秘高并发IO的底层原理，并介绍如何让单体Java应用支持百万级的高并发；从传统的阻塞式OIO开始，细致地解析Reactor高性能模式，介绍高性能网络开发的基础知识。这些非常底层的原理知识和基础知识非常重要，是开发过程中解决Java实际问题必不可少的。</p>
<p>第5～8章重点讲解Netty。目前Netty是高性能通信框架皇冠上当之无愧的明珠，是支撑其他众多著名的高并发、分布式、大数据框架底层的框架。这几章从Reactor模式入手，以“四两拨千斤”的方式为大家介绍Netty原理。同时，还将介绍如何通过Netty来解决网络编程中的重点难题，如Protobuf序列化问题、半包问题等。</p>
<p>第9～12章从TCP、HTTP入手，介绍客户端与服务端、服务端与服务端之间的高性能HTTP通信和WebSocket通信。这几章深入浅出地介绍TCP、HTTP、WebSocket三大常用的协议，以及如何基于Netty实现HTTP、WebSocket高性能通信。</p>
<p>第13章对ZooKeeper进行详细的介绍。除了全面地介绍Curator API之外，还从实战的角度出发介绍如何使用ZooKeeper设计分布式ID生成器，并对重要的SnowFlake算法进行详细的介绍。另外，还结合小故事以图文并茂的方式浅显易懂地介绍分布式锁的基本原理。</p>
<p>第14章从实战开发层面对Redis进行介绍，详细介绍Redis的5种数据类型、客户端操作指令、Jedis Java API。另外，还通过spring-data-redis来完成数据分布式缓存的实战案例，详尽地介绍Spring的缓存注解以及涉及的SpEL表达式语言。</p>
<p>第15章通过CrazyIM项目为大家介绍一个亿级流量的高并发IM系统模型，这个高并发架构的系统模型不仅仅限于IM系统，通过简单的调整和适配就可以应用于当前主流的Java后台系统。</p>
<h1 id="《Java高并发核心编程》卷1：自序摘抄"><a href="#《Java高并发核心编程》卷1：自序摘抄" class="headerlink" title="《Java高并发核心编程》卷1：自序摘抄"></a>《Java高并发核心编程》卷1：自序摘抄</h1><p>目前<strong>学习技术的途径</strong>大致有三种：<br>（1）阅读博文；通过途径1（阅读博文）获得的知识，往往过于碎片化，难成体系。这种途径更适用于了解技术趋势、解决问题时进行资料查阅。<br>（2）观看视频；通过途径2（观看视频）获取知识时，需要耗费大量的时间，而且很多视频是填鸭式的知识灌输。所以，途径2更适用于初学者。对于有经验、能动性高的Java工程师来说，途径2的效率太低，需要大量的时间成本。<br>（3）阅读书籍。通过途径3（阅读书籍）获取知识有一个显著的优势：书籍能以很小的体积承载巨量知识，而且所承载的是系统化、层次化的知识。</p>
<p>上述三种途径各有优劣，鉴于Java高并发所涉及的核心技术比较多，包括Spring Cloud、Nginx、JUC、JMM、Kafak、ElasticSearch等，将已出版的、在写的、规划中的图书整合成一个高并发核心编程的图书系列，大致清单如下：</p>
<ul>
<li>（1）<strong>《Netty、Redis、ZooKeeper高并发实战》</strong>：从操作系统底层的IO原理、Reactor高并发模式入手，介绍Java分布式、高并发通信原理，并指导大家进行高并发IM实战。此书已于2019年8月出版，由于内容略微单薄，特进行内容的完善和升级，升级版进行了书名的变更，新书名为《Java高并发核心编程　卷1：NIO、Netty、Redis、ZooKeeper》。</li>
<li>（2）<strong>《Spring Cloud、Nginx高并发核心编程》</strong>[1]：涵盖Spring Cloud、Nginx的核心原理和编程知识，并指导大家编写一个高并发的秒杀实战程序。此书已于2020年10月出版。</li>
<li>（3）<strong>《Java高并发核心编程　卷1：NIO、Netty、Redis、ZooKeeper》</strong>：介绍Reactor模式、Netty、ZooKeeper、Redis、TCP、HTTP、ebSocket、NIO等Java高性能通信的核心原理和编程知识，并指导大家编写一个高并发的分布式IM实战程序——CrazyIM。此卷即为本书，作为《Netty、Redis、ZooKeeper高并发实战》一书的升级版，对上一版本的内容进行了大量的优化和扩充。和上一版本相比，此卷知识量更大，所以学习价值也更高。</li>
<li>（4）<strong>《Java高并发核心编程　卷2：多线程、锁、JMM、JUC、高并发设计模式》</strong>：聚焦Java高并发基础知识，内容包括多线程、线程池、JMM内存模型、JUC并发包、AQS同步器、高并发容器类、高并发设计模式等。</li>
<li>（5）<strong>《Java高并发核心编程　卷3》（最终书名待定）</strong>：覆盖Kafka、RocketMQ、ElasticSearch等重要的高并发中间件的核心原理和编程知识。</li>
</ul>
<h1 id="《Java高并发核心编程》卷1：第1章高并发必备技能摘抄"><a href="#《Java高并发核心编程》卷1：第1章高并发必备技能摘抄" class="headerlink" title="《Java高并发核心编程》卷1：第1章高并发必备技能摘抄"></a>《Java高并发核心编程》卷1：第1章高并发必备技能摘抄</h1><p>随着5G应用、多终端应用、物联网应用、工业互联应用、大数据应用、人工智能应用的飞速发展，高并发开发时代已然到来，能够驾驭高并发和大数据的物联网架构师、高并发架构师、大数据架构师、Java高级工程师在人才市场也随之成为“香饽饽”，<strong>Netty、Redis、ZooKeeper、高性能HTTP服务器组件（如Nginx）、高并发Java组件（JUC包）等则成为广大Java工程师所必须掌握的开发技能。</strong></p>
<h2 id="Netty高并发异步IO框架介绍"><a href="#Netty高并发异步IO框架介绍" class="headerlink" title="Netty高并发异步IO框架介绍"></a>Netty高并发异步IO框架介绍</h2><p>Netty是<strong>JBOSS提供的一个Java开源框架</strong>，是基于NIO的客户端&#x2F;服务器编程框架，既能快速开发<strong>高并发、高可用、高可靠</strong>的网络服务器程序，也能开发高可用、高可靠的客户端程序。</p>
<blockquote>
<p>的NIO是指非阻塞输入输出（Non-Blocking IO），也称非阻塞IO</p>
</blockquote>
<h3 id="Netty用例"><a href="#Netty用例" class="headerlink" title="Netty用例"></a>Netty用例</h3><p>消息中间件：Kafka、RocketMQ<br>开源搜索引擎：ElasticSearch<br>Hadoop RPC框架：Hadoop的Avro<br>微服务框架：Dubbo</p>
<h3 id="Netty机制及特点："><a href="#Netty机制及特点：" class="headerlink" title="Netty机制及特点："></a>Netty机制及特点：</h3><p>Netty之所以受青睐，是因为它提供了异步的、事件驱动的网络应用程序框架和工具。作为一个异步框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便地主动获取或者通过通知机制获得IO操作结果。<br>与JDK原生NIO相比，Netty提供了十分简单易用的API，因而非常适合网络编程。Netty主要是基于NIO来实现的，在Netty中也可以提供阻塞IO的服务。<br>Netty之所以这么火，与它的巨大优点是密不可分的，大致可以总结如下：</p>
<ul>
<li>API使用简单，开发门槛低。</li>
<li>功能强大，预置了多种编解码功能，支持多种主流协议。</li>
<li>定制能力强，可以通过ChannelHandler对通信框架进行灵活扩展。</li>
<li>性能高，与其他业界主流的NIO框架相比，Netty的综合性能最优。</li>
<li>成熟、稳定，Netty修复了在JDK NIO中所有已发现的Bug，业务开发人员不需要再为NIO的Bug而烦恼。</li>
<li>社区活跃，版本迭代周期短，发现的Bug可以被及时修复。</li>
</ul>
<h2 id="Redis高并发缓存利器"><a href="#Redis高并发缓存利器" class="headerlink" title="Redis高并发缓存利器"></a>Redis高并发缓存利器</h2><h3 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h3><p>Redis是<strong>Remote Dictionary Server（远程字典服务器）</strong>的缩写，最初是作为数据库的工具来使用的，是目前使用广泛、高效的开源缓存。Redis使用C语言开发，将数据保存在内存中，可以看成是一款<strong>纯内存的数据库</strong>，所以它的数据存取速度非常快。一些经常用并且创建时间较长的内容可以缓存到Redis中，而应用程序能以极快的速度存取这些内容。举例来说，如果某个页面会经常被访问到，而创建页面时需要多次访问数据库，造成网页内容的生成时间较长，那么就可以使用Redis将这个页面缓存起来，从而减轻网站的负担，降低网站的延迟。</p>
<h3 id="Redis特点及场景"><a href="#Redis特点及场景" class="headerlink" title="Redis特点及场景"></a>Redis特点及场景</h3><p>（1）速度快。不需要等待磁盘的IO，而是在内存之间进行数据存储和查询，速度非常快。当然，缓存的数据总量不能太大，因为受到物理内存空间大小的限制。<br>（2）丰富的数据结构，有String、List、Hash、Set、SortedSet五种类型。<br>（3）单线程，避免了线程切换和锁机制的性能消耗。<br>（4）可持久化。支持RDB与AOF两种方式，将内存中的数据写入外部的物理存储设备。<br>（5）支持发布&#x2F;订阅。<br>（6）支持Lua脚本。<br>（7）支持分布式锁。在分布式系统中，不同的节点需要访问同一个资源时，往往需要通过互斥机制来防止彼此干扰，并且保证数据的一致性。在这种情况下，需要用到分布式锁。分布式锁和Java的锁用于实现不同线程之间的同步访问，原理上是类似的。<br>（8）支持原子操作和事务。Redis事务是一组命令的集合。一个事务中的命令要么都执行，要么都不执行。如果命令在运行期间出现错误，不会自动回滚。<br>（9）支持主-从（Master-Slave）复制与高可用（Redis Sentinel）集群（3.0版本以上）。<br>（10）支持管道。Redis管道是指客户端可以将多个命令一次性发送到服务器，然后由服务器一次性返回所有结果。管道技术的优点是，在批量执行命令的应用场景中，可以大大减少网络传输的开销，提高性能。</p>
<p><strong>Redis通过键-值对（Key-Value Pair）的形式来存储数据</strong>，类似于Java中的Map（映射）。Redis的Key（键）只能是String（字符串）类型，Value（值）则可以是String类型、Map类型、List（列表）类型、Set（集合）类型、SortedSet（有序集合）类型。</p>
<p><strong>Redis的主要应用场景</strong>是缓存（数据查询、短连接、新闻内容、商品内容等）、分布式会话（Session）、聊天室的在线好友列表、任务队列（秒杀、抢购、12306等）、应用排行榜、访问统计、数据过期处理（可以精确到毫秒）。</p>
<h2 id="ZooKeeper高并发分布式利器"><a href="#ZooKeeper高并发分布式利器" class="headerlink" title="ZooKeeper高并发分布式利器"></a>ZooKeeper高并发分布式利器</h2><p>单体应用在达到性能瓶颈之后，就必须靠分布式集群解决高并发问题，而集群的分布式架构和集群节点之间的交互一定少不了可靠的分布式协调工具，<strong>ZooKeeper就是目前极为重要的分布式协调工具。</strong><br>雅虎的开发人员就试图开发一个通用的无单点问题的分布式协调框架。此框架的命名过程也是非常有趣的。在项目初期给这个项目命名时，准备和很多项目一样，按照雅虎公司的惯例使用动物的名字来命名（例如著名的Pig项目）。在探讨取什么名字的时候，研究院的首席科学家Raghu Ramakrishnan开玩笑说：“再这样下去，我们这儿就变成动物园了。”此话一出，大家纷纷表示新框架就叫动物园管理员吧，于是<strong>ZooKeeper（动物园管理员）诞生了。而ZooKeeper正好是用来协调分布式环境的不同节点的，形象地说，可以理解为协调各个以动物命名的分布式组件</strong>，所以ZooKeeper也就“名副其实”了。</p>
<h3 id="ZooKeeper的特点及优势"><a href="#ZooKeeper的特点及优势" class="headerlink" title="ZooKeeper的特点及优势"></a>ZooKeeper的特点及优势</h3><p>ZooKeeper的<strong>核心优势是实现了分布式环境的数据一致性</strong>，简单地说：每时每刻我们访问ZooKeeper的树结构时，不同的节点返回的数据都是一致的。也就是说，对ZooKeeper进行数据访问时，无论是什么时间，都不会引起“脏读”“幻读”“不可重复读”问题。<br><strong>“脏读”“幻读”“不可重复读”是数据库事务的概念</strong>，当然，ZooKeeper也可以被理解为一种简单的<strong>分布式数据库</strong>。</p>
<ul>
<li>“脏读”是指一个事务中访问到了另外一个事务未提交的数据。</li>
<li>“不可重复读”是指在一个事务内根据同一个条件对数据进行多次查询，但是结果却不一致，原因是其他事务对该数据进行了修改。</li>
<li>“幻读”是指当两个完全相同的查询执行时，第二次查询所返回的结果集和第一次查询所返回的结果集不相同，原因也是另外一个事务新增、删除了第一个事务结果集中的数据。</li>
</ul>
<blockquote>
<p>“不可重复读”和“幻读”的区别是：<strong>“不可重复读”关注的重点在于记录的更新操作</strong>，对同样的记录，再次读取后发现返回的数据值不一样了；“幻读”关注的重点在于<strong>记录新增或者删除操作（数据条数发生了变化）</strong>，同样的条件第一次和第二次查询出来的记录数不一样。</p>
</blockquote>
<h2 id="Nginx-RPC高并发的通信-调用技术"><a href="#Nginx-RPC高并发的通信-调用技术" class="headerlink" title="Nginx&#x2F;RPC高并发的通信&#x2F;调用技术"></a>Nginx&#x2F;RPC高并发的通信&#x2F;调用技术</h2><h3 id="QPS在十万级的Web应用架构大致图"><a href="#QPS在十万级的Web应用架构大致图" class="headerlink" title="QPS在十万级的Web应用架构大致图"></a>QPS在十万级的Web应用架构大致图</h3><p>Nginx是一个强大的Web服务器软件，用于处理高并发的HTTP请求和作为反向代理服务器进行负载均衡，具有高性能、轻量级、内存消耗少、强大的负载均衡能力等优势。<br><img src="/posts/dd6fbad0/QPS-10T-1.png" alt="alt text"><br>对于十万级流量的系统应用而言，其架构一般可以分为三层：服务层、接入层、客户端层。<br><strong>服务层一般执行的是Java应用程序</strong>，可以细分为传统的单体应用和目前主流的Spring Cloud分布式应用。传统的单体Java应用执行在Tomcat服务器上，目前主流的Spring Cloud微服务应用执行在内嵌的Tomcat服务器上。<br><strong>接入层主要完成鉴权、限流、反向代理和负载均衡等功能。</strong>由于在静态资源、登录验证等简单逻辑的处理性能上Nginx和Tomcat不可同日而语（一般在10倍以上），因此接入层基本上都是使用Nginx + Lua扩展作为接入服务器。另外，为了保证Nginx接入服务器的高可用，会搭建有冗余的接入服务器，然后使用KeepAlived中间件进行高可用监控管理并且虚拟出外部IP，供外部访问。</p>
<h3 id="QPS在百千万级的Web应用架构大致图"><a href="#QPS在百千万级的Web应用架构大致图" class="headerlink" title="QPS在百千万级的Web应用架构大致图"></a>QPS在百千万级的Web应用架构大致图</h3><p>对于十万级QPS流量的Web应用，如果流量增长到百万级，可以对接入层Nginx进行横向扩展，甚至可以引入LVS进行负载均衡。<br><img src="/posts/dd6fbad0/QPS-KW-1.png" alt="alt text"><br>对于千万级QPS的Web应用，除了服务层的独立Tomcat或者Spring Cloud微服务节点需要进行不断的横向扩展之外，还需要进行以下两大增强：<br>（1）引入LVS负载均衡层，进行请求分发和接入层的负载均衡。<br>（2）引入DNS服务器的负载均衡，可以在域名下面添加多个IP，由DNS服务器进行多个IP之间的负载均衡，甚至可以按照就近原则为用户返回最近的服务器IP地址。<br>总之，如何抵抗十万级甚至千万级QPS访问洪峰，涉及大量的开发知识、运维知识。对于开发人员来说，并不一定需要掌握太多的操作系统层面（如LVS）运维知识，主要原因是术业有专攻，一般会有专业的运维人员去解决系统的运行问题。但是对千万级QPS系统中所涉及的高并发方面的开发知识，则是开发人员必须掌握的。<br>在十万级甚至千万级QPS的Web应用架构中，如何提高平台内部的接入层Nginx和服务层Tomcat（或者其他Java容器）之间的HTTP通信能力，涉及高并发HTTP通信这个核心技术问题，这是本书后面章节会从TCP、HTTP层面出发所重点剖析和解读的问题。</p>
<h3 id="微服务的高并发RPC技术Feign"><a href="#微服务的高并发RPC技术Feign" class="headerlink" title="微服务的高并发RPC技术Feign"></a>微服务的高并发RPC技术Feign</h3><p>分布式微服务架构目前已经成为Java应用的主流架构，在接入层同样会与Nginx结合，所以常常都是Nginx + Spring Cloud架构。<br><img src="/posts/dd6fbad0/microservices-rpc.png" alt="alt text"><br><strong>微服务Provider实例之间的RPC在Spring Cloud全家桶技术体系中是由Feign基于Ribbon完成的</strong>，并由<strong>Hystrix组件提供RPC的熔断、回退、限流</strong>等保护。</p>
<h1 id="《Java高并发核心编程》卷1：第2章高并发IO底层原理"><a href="#《Java高并发核心编程》卷1：第2章高并发IO底层原理" class="headerlink" title="《Java高并发核心编程》卷1：第2章高并发IO底层原理"></a>《Java高并发核心编程》卷1：第2章高并发IO底层原理</h1><h2 id="IO读写的基本原理"><a href="#IO读写的基本原理" class="headerlink" title="IO读写的基本原理"></a>IO读写的基本原理</h2><h3 id="操作系统的内核空间与用户空间"><a href="#操作系统的内核空间与用户空间" class="headerlink" title="操作系统的内核空间与用户空间"></a>操作系统的内核空间与用户空间</h3><p>为了了避免用户进程直接操作内核，保证内核安全，操作系统将内存（虚拟内存）划分为两部分：<strong>一部分是内核空间（Kernel Space）</strong>，另<strong>一部分是用户空间（User-Space）</strong>。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态；用户程序运行在用户空间，对应的进程处于用户态。</p>
<p>操作系统的核心是内核程序，它独立于普通的应用程序，既有权限访问受保护的内核空间，也有权限访问硬件设备，而普通的应用程序并没有这样的权限。</p>
<p>内核空间总是驻留在内存中，是为操作系统的内核保留的。应用程序不允许直接在内核空间区域进行读写，也不允许直接调用内核代码定义的函数。每个应用程序进程都有一个单独的用户空间，对应的进程处于用户态，用户态进程不能访问内核空间中的数据，也不能直接调用内核函数，因此需要将进程切换到内核态才能进行系统调用。</p>
<h3 id="操作系统的内核态与用户态"><a href="#操作系统的内核态与用户态" class="headerlink" title="操作系统的内核态与用户态"></a>操作系统的内核态与用户态</h3><p>内核态进程可以执行任意命令，调用系统的一切资源，而用户态进程只能执行简单的运算，不能直接调用系统资源，那么问题来了：<br>用户态进程如何执行系统调用呢？答案是：<strong>用户态进程必须通过系统调用（System Call）向内核发出指令，完成调用系统资源之类的操作</strong>。</p>
<h3 id="操作系统的内核缓冲区与用户进程缓冲区"><a href="#操作系统的内核缓冲区与用户进程缓冲区" class="headerlink" title="操作系统的内核缓冲区与用户进程缓冲区"></a>操作系统的内核缓冲区与用户进程缓冲区</h3><p>缓冲区的目的是<strong>减少与设备之间的频繁物理交换</strong>。<strong>操作系统会对内核缓冲区进行监控</strong>，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作，通过这种机制来提升系统的性能。至于具体什么时候执行系统中断（包括读中断、写中断）则由操作系统的内核来决定，应用程序不需要关心。</p>
<p>用户程序进行IO的读写依赖于底层的IO读写，基本上会用到底层的<strong>read和write两大系统调用</strong>。虽然在不同的操作系统中read和write两大系统调用的名称和形式可能不完全一样，但是它们的基本功能是一样的。<br>操作系统层面的read系统调用并不是直接从物理设备把数据读取到应用的内存中，write系统调用也不是直接把数据写入物理设备。<strong>上层应用无论是调用操作系统的read还是调用操作系统的write，都会涉及缓冲区</strong>。具体来说，<strong>上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区</strong>，通过<strong>操作系统的write系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区</strong>。<br><img src="/posts/dd6fbad0/systemcall-read-write.png" alt="alt text"></p>
<p>简单来说，<strong>应用程序的IO操作实际上不是物理设备级别的读写，而是缓存的复制</strong>。read和write两大系统调用都不负责数据在内核缓冲区和物理设备（如磁盘、网卡等）之间的交换。这个底层的读写交换操作是由操作系统内核（Kernel）来完成的。所以，在应用程序中，<strong>无论是对socket的IO操作还是对文件的IO操作，都属于上层应用的开发，它们在输入（Input）和输出（Output）维度上的执行流程是类似的，都是在内核缓冲区和进程缓冲区之间进行数据交换</strong>。</p>
<p><strong>内核缓冲区与应用缓冲区在数量上也不同。</strong>在Linux系统中，<strong>操作系统内核只有一个内核缓冲区</strong>。每个用户程序（进程）都有自己独立的缓冲区，叫作<strong>用户缓冲区或者进程缓冲区</strong>。在大多数情况下，<strong>Linux系统中用户程序的IO读写程序并没有进行实际的IO操作</strong>，而是在用户缓冲区和内核缓冲区之间直接进行数据的交换。</p>
<h3 id="系统调用Read-write-socket示例"><a href="#系统调用Read-write-socket示例" class="headerlink" title="系统调用Read&#x2F;write&#x2F;socket示例"></a>系统调用Read&#x2F;write&#x2F;socket示例</h3><p>以read系统调用为例，看一下一个完整输入流程的两个阶段：<br>    应用程序等待数据准备好。<br>    从内核缓冲区向用户缓冲区复制数据。<br>如果是读取一个socket（套接字），那么以上两个阶段的具体处理流程如下：<br>    第一个阶段，应用程序等待数据通过网络到达网卡，当所等待的分组到达时，数据被操作系统复制到内核缓冲区中。这个工作由操作系统自动完成，用户程序无感知。<br>    第二个阶段，内核将数据从内核缓冲区复制到应用的用户缓冲区。<br>再具体一点，如果是在Java客户端和服务端之间完成一次socket请求和响应（包括read和write）的数据交换，其完整的流程如下：</p>
<ul>
<li>客户端发送请求：Java客户端程序通过write系统调用将数据复制到内核缓冲区，Linux将内核缓冲区的请求数据通过客户端机器的网卡发送出去。在服务端，这份请求数据会从接收网卡中读取到服务端机器的内核缓冲区。</li>
<li>服务端获取请求：Java服务端程序通过read系统调用从Linux内核缓冲区读取数据，再送入Java进程缓冲区。</li>
<li>服务端业务处理：Java服务器在自己的用户空间中完成客户端的请求所对应的业务处理。</li>
<li>服务端返回数据：Java服务器完成处理后，构建好的响应数据将从用户缓冲区写入内核缓冲区，这里用到的是write系统调用，操作系统会负责将内核缓冲区的数据发送出去。</li>
<li>发送给客户端：服务端Linux系统将内核缓冲区中的数据写入网卡，网卡通过底层的通信协议将数据发送给目标客户端。</li>
</ul>
<h2 id="四种主要的IO模型"><a href="#四种主要的IO模型" class="headerlink" title="四种主要的IO模型"></a>四种主要的IO模型</h2><p>常见的IO模型有四种。</p>
<h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p><strong>阻塞与非阻塞</strong><br>阻塞IO指的是需要内核IO操作彻底完成后才返回到用户空间执行用户程序的操作指令。“阻塞”指的是用户程序（发起IO请求的进程或者线程）的执行状态。可以说传统的IO模型都是阻塞IO模型，并且在Java中默认创建的socket都属于阻塞IO模型</p>
<p><strong>同步与异步</strong><br>简单来说，可以将同步与异步看成发起IO请求的两种方式。<br><strong>同步IO是指用户空间（进程或者线程）是主动发起IO请求的一方，系统内核是被动接收方</strong>。<br><strong>异步IO则反过来，系统内核是主动发起IO请求的一方，用户空间是被动接收方。</strong></p>
<p><strong>同步阻塞IO</strong>（Blocking IO）指的是用户空间（或者线程）主动发起，需要等待内核IO操作彻底完成后才返回到用户空间的IO操作。在IO操作过程中，发起IO请求的用户进程（或者线程）处于阻塞状态。<br><img src="/posts/dd6fbad0/%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO.png" alt="alt text"><br>举个例子，在Java中发起一个socket的read操作的系统调用，流程大致如下：<br>（1）从Java进行IO读后发起read系统调用开始，用户线程（或者线程）就进入阻塞状态。<br>（2）当系统内核收到read系统调用后就开始准备数据。一开始，数据可能还没有到达内核缓冲区（例如，还没有收到一个完整的socket数据包），这时内核就要等待。<br>（3）内核一直等到完整的数据到达，就会将数据从内核缓冲区复制到用户缓冲区（用户空间的内存），然后内核返回结果（例如返回复制到用户缓冲区中的字节数）。<br>（4）直到内核返回后用户线程才会解除阻塞的状态，重新运行起来。<br>阻塞IO的特点是在内核执行IO操作的两个阶段，发起IO请求的用户进程（或者线程）被阻塞了。<br><strong>阻塞IO的优点是</strong>：应用程序开发非常简单；在阻塞等待数据期间，<strong>用户线程挂起</strong>，基本不会占用CPU资源。<br><strong>阻塞IO的缺点是</strong>：一般情况下会为每个连接配备一个独立的线程，一个线程维护一个连接的IO操作。在并发量小的情况下，这样做没有什么问题。在高并发的应用场景下，阻塞IO模型需要大量的线程来维护大量的网络连接，内存、线程切换开销会非常巨大，性能很低，基本上是不可用的。</p>
<h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p><strong>非阻塞IO</strong>（Non-Blocking IO，NIO）指的是用户空间的程序不需要等待内核IO操作彻底完成，可以立即返回用户空间去执行后续的指令，即发起IO请求的用户进程（或者线程）处于非阻塞状态，与此同时，内核会立即返回给用户一个IO状态值。</p>
<p><strong>阻塞和非阻塞的区别是什么呢？</strong><br>阻塞是指用户进程（或者线程）一直在等待，而不能做别的事情；<br>非阻塞是指用户进程（或者线程）获得内核返回的状态值就返回自己的空间，可以去做别的事情。<br>在Java中，非阻塞IO的socket被设置为NONBLOCK模式。</p>
<p><strong>同步非阻塞IO</strong>指的是用户进程主动发起，不需要等待内核IO操作彻底完成就能立即返回用户空间的IO操作。在IO操作过程中，发起IO请求的用户进程（或者线程）处于非阻塞状态。</p>
<blockquote>
<p>同步非阻塞IO也可以简称为NIO，但是它不是Java编程中的NIO。Java编程中的NIO（New IO）类库组件所归属的不是基础IO模型中的NIO模型，而是IO多路复用模型。<br><img src="/posts/dd6fbad0/%E5%90%8C%E6%AD%A5N%E9%98%BB%E5%A1%9EIO.png" alt="alt text"><br>举个例子，发起一个非阻塞socket的read操作的系统调用，流程如下：<br>（1）在内核数据没有准备好的阶段，用户线程发起IO请求时立即返回。所以，为了读取最终的数据，用户进程（或者线程）需要不断地发起IO系统调用。<br>（2）内核数据到达后，用户进程（或者线程）发起系统调用，用户进程（或者线程）阻塞。内核开始复制数据，它会将数据从内核缓冲区复制到用户缓冲区，然后内核返回结果（例如返回复制到的用户缓冲区的字节数）。<br>（3）用户进程（或者线程）读到数据后，才会解除阻塞状态，重新运行起来。也就是说，用户空间需要经过多次尝试才能保证最终真正读到数据，而后继续执行。<br><strong>同步非阻塞IO的特点</strong>是应用程序的线程需要不断地进行IO系统调用，轮询数据是否已经准备好，如果没有准备好就继续轮询，直到完成IO系统调用为止。<br><strong>同步非阻塞IO的优点</strong>是每次发起的IO系统调用在内核等待数据过程中可以立即返回，用户线程不会阻塞，实时性较好。<br><strong>同步非阻塞IO的缺点</strong>是不断地轮询内核，这将占用大量的CPU时间，效率低下。<br>总体来说，在高并发应用场景中，同步非阻塞IO是性能很低的，也是基本不可用的，一般Web服务器都不使用这种IO模型。在Java的实际开发中，不会涉及这种IO模型，但是此模型还是有价值的，其作用在于其他IO模型中可以使用非阻塞IO模型作为基础，以实现其高性能。</p>
</blockquote>
<h3 id="IO多路复用-异步阻塞IO"><a href="#IO多路复用-异步阻塞IO" class="headerlink" title="IO多路复用-异步阻塞IO"></a>IO多路复用-异步阻塞IO</h3><p>如何避免同步非阻塞IO模型中轮询等待的问题呢？答案是<strong>采用IO多路复用模型。</strong><br>为了提高性能，<strong>操作系统引入了一种新的系统调用，专门用于查询IO文件描述符（含socket连接）的就绪状态</strong>。在Linux系统中，<strong>新的系统调用为select&#x2F;epoll系统调用</strong>。通过该系统调用，一个用户进程（或者线程）可以<strong>监视多个文件描述符</strong>，一旦某个描述符就绪（一般是内核缓冲区可读&#x2F;可写），内核就能够将文件描述符的就绪状态返回给用户进程（或者线程），用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。<br><strong>IO多路复用（IO Multiplexing）属于一种经典的Reactor模式实现</strong>，有时也称为<strong>异步阻塞IO</strong>，Java中的Selector属于这种模型。<br>目前支持IO多路复用的系统调用有select、epoll等。几乎所有的操作系统都支持select系统调用，它具有良好的跨平台特性。epoll是在Linux 2.6内核中提出的，是select系统调用的Linux增强版本。在IO多路复用模型中通过select&#x2F;epoll系统调用，单个应用程序的线程可以不断地轮询成百上千的socket连接的就绪状态，当某个或者某些socket网络连接有IO就绪状态时就返回这些就绪的状态（或者说就绪事件）。</p>
<p>举个例子来说明IO多路复用模型的流程。发起一个多路复用IO的read操作的系统调用，流程如下：<br>（1）选择器注册。首先，将需要read操作的目标文件描述符（socket连接）提前注册到Linux的select&#x2F;epoll选择器中，在Java中所对应的选择器类是Selector类。然后，开启整个IO多路复用模型的轮询流程。<br>（2）就绪状态的轮询。通过选择器的查询方法，查询所有提前注册过的目标文件描述符（socket连接）的IO就绪状态。通过查询的系统调用，内核会返回一个就绪的socket列表。当任何一个注册过的socket中的数据准备好或者就绪了就说明内核缓冲区有数据了，内核将该socket加入就绪的列表中，并且返回就绪事件。<br>（3）用户线程获得了就绪状态的列表后，根据其中的socket连接发起read系统调用，用户线程阻塞。内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区。<br>（4）复制完成后，内核返回结果，用户线程才会解除阻塞的状态，用户线程读取到了数据，继续执行。<br>IO多路复用模型的read系统调用流程如图所示<br><img src="/posts/dd6fbad0/IO-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png" alt="alt text"></p>
<blockquote>
<p>在用户进程进行IO就绪事件的轮询时，需要调用选择器的select查询方法，发起查询的用户进程或者线程是阻塞的。当然，如果使用了查询方法的非阻塞的重载版本，发起查询的用户进程或者线程也不会阻塞，重载版本会立即返回。</p>
</blockquote>
<p><strong>IO多路复用模型的特点</strong>是：IO多路复用模型的IO涉及两种系统调用，一种是IO操作的系统调用，另一种是select&#x2F;epoll就绪查询系统调用。IO多路复用模型建立在操作系统的基础设施之上，即操作系统的内核必须能够提供多路分离的系统调用select&#x2F;epoll。和NIO模型相似，多路复用IO也需要轮询。负责select&#x2F;epoll状态查询调用的线程，需要不断地进行select&#x2F;epoll轮询，以找出达到IO操作就绪的socket连接。<br>IO多路复用模型与同步非阻塞IO模型是有密切关系的，具体来说，注册在选择器上的每一个可以查询的socket连接一般都设置成同步非阻塞模型，只是这一点对于用户程序而言是无感知的。<br><strong>IO多路复用模型的优点是一个选择器查询线程可以同时处理成千上万的网络连接</strong>，所以用户程序不必创建大量的线程，也不必维护这些线程，从而大大减少了系统的开销。与一个线程维护一个连接的阻塞IO模式相比，这一点是IO多路复用模型的最大优势。<br>通过JDK的源码可以看出，<strong>Java语言的NIO组件在Linux系统上是使用epoll系统调用实现的</strong>。所以，Java语言的NIO组件所使用的就是IO多路复用模型。<br><strong>IO多路复用模型的缺点是</strong>，本质上select&#x2F;epoll<strong>系统调用是阻塞式的，属于同步IO</strong>，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个<strong>读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型</strong>。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>异步IO（Asynchronous IO，AIO）指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者。在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕并放在了用户缓冲区内，内核在IO完成后通知用户线程直接使用即可。<br><strong>异步IO类似于Java中典型的回调模式</strong>，用户进程（或者线程）<strong>向内核空间注册了各种IO事件的回调函数</strong>，由内核去主动调用。<br><strong>异步IO模型的基本流程是</strong>：用户线程通过系统调用<strong>向内核注册</strong>某个IO操作。内核在整个IO操作（包括数据准备、数据复制）完成后通知用户程序，用户执行后续的业务操作。<br>在异步IO模型中，在整个内核的数据处理过程（包括内核将数据从网络物理设备（网卡）读取到内核缓冲区、将内核缓冲区的数据复制到用户缓冲区）中，用户程序都不需要阻塞。<br>异步IO模型的流程如图所示。<br><img src="/posts/dd6fbad0/AIO.png" alt="alt text"><br>举个例子，发起一个异步IO的read操作的系统调用，流程如下：<br>（1）当用户线程发起了read系统调用后，立刻就可以去做其他的事，用户线程不阻塞。<br>（2）内核开始IO的第一个阶段：准备数据。准备好数据，内核就会将数据从内核缓冲区复制到用户缓冲区。<br>（3）内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调方法，告诉用户线程read系统调用已经完成，数据已经读入用户缓冲区。<br>（4）用户线程读取用户缓冲区的数据，完成后续的业务操作。<br><strong>异步IO模型的特点是</strong>在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的。用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数。正因为如此，异步IO有的时候也被称为信号驱动IO。<br><strong>异步IO模型的缺点</strong>是应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，也就是说需要底层内核提供支持。<br>理论上来说，异步IO是真正的异步输入输出，它的吞吐量高于IO多路复用模型的吞吐量。就目前而言，Windows系统下通过IOCP实现了真正的异步IO。在Linux系统下，异步IO模型在2.6版本才引入，JDK对它的支持目前并不完善，因此异步IO在性能上没有明显的优势。<br><strong>大多数高并发服务端的程序都是基于Linux系统的</strong>。因而，目前这类高并发网络应用程序的开发大多采用IO多路复用模型。<strong>大名鼎鼎的Netty框架使用的就是IO多路复用模型，而不是异步IO模型</strong>。</p>
<h2 id="Linux下的高并发配置限制"><a href="#Linux下的高并发配置限制" class="headerlink" title="Linux下的高并发配置限制"></a>Linux下的高并发配置限制</h2><p>Linux下的高并发配置限制就是Linux操作系统中文件句柄数的限制。在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。原因是Linux系统的默认值为1024，也就是说，一个进程最多可以接受1024个socket连接，这是远远不够的。<br><strong>文件句柄也叫文件描述符</strong><br>在Linux系统中，文件可分为普通文件、目录文件、链接文件和设备文件。文件描述符（File Descriptor）是内核为了高效管理已被打开的文件所创建的索引，是一个非负整数（通常是小整数），用于指代被打开的文件。所有的IO系统调用（包括socket的读写调用）都是通过文件描述符完成的。</p>
<p>在Linux下，通过调用ulimit命令可以看到一个进程能够打开的最大文件句柄数量。这个命令的具体使用方法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure>
<p>ulimit命令是用来显示和修改当前用户进程的基础限制命令，-n选项用于引用或设置当前的文件句柄数量的限制值，Linux系统的默认值为1024。<br>理论上，1024个文件描述符对绝大多数应用（例如Apache、桌面应用程序）来说已经足够，对于一些用户基数很大的高并发应用则是远远不够的。一个高并发的应用面临的并发连接数往往是十万级、百万级、千万级，甚至像腾讯QQ一样的上亿级。<br>文件句柄数不够，会导致什么后果呢？当单个进程打开的文件句柄数量超过了系统配置的上限值时会发出“Socket&#x2F;File:Can’t open so many files”的错误提示。<br>所以，对于高并发、高负载的应用，必须调整这个系统参数，以适应并发处理大量连接的应用场景。可以通过ulimit来设置这两个参数，方法如下：<br>ulimit  -n  1000000<br>在上面的命令中，n的值设置越大，可以打开的文件句柄数量越大。建议以root用户来执行此命令。<br>使用ulimit命令有一个缺陷，即该命令只能修改当前用户环境的一些基础限制，仅在当前用户环境有效。也就是说，在当前的终端工具连接当前shell期间，修改是有效的，一旦断开用户会话，或者说用户退出Linux，它的数值就又变回系统默认的1024了。并且，系统重启后，句柄数量会恢复为默认值。<br>ulimit命令只能用于临时修改，如果想永久地把最大文件描述符数量值保存下来，可以编辑<code>/etc/rc.local</code>开机启动文件，在文件中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 1000000</span><br></pre></td></tr></table></figure>
<p>以上示例增加了-S和-H两个命令选项。选项-S表示软性极限值，H表示硬性极限值。硬性极限值是实际的限制，就是最大可以是100万，不能再多了。软性极限值则是系统发出警告（Warning）的极限值，超过这个极限值，内核会发出警告。<br>普通用户通过ulimit命令可将软性极限值更改到硬性极限值的最大设置值。如果要更改硬性极限值，必须拥有root用户权限。<br>要彻底解除Linux系统的最大文件打开数量的限制，可以通过编辑Linux的极限配置文件&#x2F;etc&#x2F;security&#x2F;limits.conf来做到。修改此文件，加入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 1000000 </span><br><span class="line">hard nofile 1000000</span><br></pre></td></tr></table></figure>
<p>soft nofile表示软性极限，hard nofile表示硬性极限。<br>举个实际例子，在使用和安装目前非常流行的分布式搜索引擎ElasticSearch时，必须修改这个文件，以增加最大的文件描述符的极限值。当然，在生产环境运行Netty时，也需要修改&#x2F;etc&#x2F;security&#x2F;limits.conf文件来增加文件描述符数量的极限值。</p>
<h1 id="《Java高并发核心编程》卷1：第3章Java-NIO核心详解"><a href="#《Java高并发核心编程》卷1：第3章Java-NIO核心详解" class="headerlink" title="《Java高并发核心编程》卷1：第3章Java NIO核心详解"></a>《Java高并发核心编程》卷1：第3章Java NIO核心详解</h1><h2 id="Java-NIO组件介绍"><a href="#Java-NIO组件介绍" class="headerlink" title="Java NIO组件介绍"></a>Java NIO组件介绍</h2><p>高性能的Java通信绝对离不开Java NIO组件，现在<strong>主流的技术框架或中间件服务器都使用了Java NIO组件，譬如Tomcat、Jetty、Netty</strong>。<br>在1.4版本之前，Java IO类库是阻塞IO；<br>从1.4版本开始，引进了新的异步IO库，被称为Java New IO类库，简称为Java NIO。New IO类库的目标就是要让Java支持非阻塞IO，基于此，更多的人喜欢称Java NIO为非阻塞IO（Non-Blocking IO），称“老的”阻塞式Java IO为OIO（Old IO）。总体上说，NIO弥补了原来面向流的OIO同步阻塞的不<br>足，为标准Java代码提供了高速、面向缓冲区的IO。</p>
<p>Java NIO类库包含以下三个<strong>核心组件</strong>：<br>    Channel（通道）<br>    Buffer（缓冲区）<br>    Selector（选择器）<br>理解了第2章的四种IO模型，大家一眼就能识别出来<strong>Java NIO属于第三种模型——IO多路复用模型</strong>。只不过，Java NIO组件提供了统一的API，为大家屏蔽了底层的操作系统的差异。</p>
<h3 id="NIO和OIO的对比"><a href="#NIO和OIO的对比" class="headerlink" title="NIO和OIO的对比"></a>NIO和OIO的对比</h3><p>在Java中，NIO和OIO的区别主要体现在三个方面：<br>（1）OIO是面向流（Stream Oriented）的，NIO是面向缓冲区（Buffer Oriented）的。<br>在一般的OIO操作中，面向字节流或字符流的IO操作总是以流式的方式顺序地从一个流（Stream）中读取一个或多个字节，因此，我们不能随意改变读取指针的位置。在NIO操作中则不同，NIO中引入了Channel和Buffer的概念。面向缓冲区的读取和写入只需要从通道读取数据到缓冲区中，或将数据从缓冲区写入通道中。NIO不像OIO那样是顺序操作，它可以随意读取Buffer中任意位置的数据。<br>（2）OIO的操作是阻塞的，而NIO的操作是非阻塞的。即NIO使用了通道和通道的多路复用技术。<br>（3）OIO没有选择器（Selector）的概念，而NIO有选择器的概念。NIO的实现是基于底层选择器的系统调用的，所以NIO需要底层操作系统提供支持；而OIO不需要用到选择器。</p>
<h3 id="Java-NIO类库之通道"><a href="#Java-NIO类库之通道" class="headerlink" title="Java NIO类库之通道"></a>Java NIO类库之通道</h3><p>在OIO中，同一个网络连接会关联到两个流：一个是输入流（Input Stream），另一个是输出流（Output Stream）。Java应用程序通过这两个流不断地进行输入和输出的操作。<br>在NIO中，一个网络连接使用一个通道表示，所有NIO的IO操作都是通过连接通道完成的。一个通道类似于OIO中两个流的结合体，既可以从通道读取数据，也可以向通道写入数据。</p>
<h3 id="Java-NIO类库之选择器"><a href="#Java-NIO类库之选择器" class="headerlink" title="Java NIO类库之选择器"></a>Java NIO类库之选择器</h3><p>在Java应用层面，<strong>如何实现对多个文件描述符的监视呢</strong>？需要用到一个非常重要的Java NIO组件——选择器。选择器可以理解为一个IO事件的监听与查询器。通过选择器，一个线程可以查询多个通道的IO事件的就绪状态。<br>从编程实现维度来说，<strong>IO多路复用编程的第一步是把通道注册到选择器中</strong>，第二步是通过选择器所提供的事件查询（select）方法来查询这些注册的通道是否有已经就绪的IO事件（例如可读、可写、网络连接完成等）。<br><strong>由于一个选择器只需要一个线程进行监控</strong>，因此我们可以很简单地使用一个线程，通过选择器去管理多个连接通道。<br>与OIO相比，<strong>NIO使用选择器的最大优势是系统开销小</strong>。系统不必为每一个网络连接（文件描述符）创建进程&#x2F;线程，从而大大减少了系统的开销。总之，一个线程负责多个连接通道的IO处理是非常高效的，这种高效来自Java的选择器组件Selector及其底层的操作系统IO多路复用技术的支持。</p>
<h3 id="Java-NIO类库之缓冲区"><a href="#Java-NIO类库之缓冲区" class="headerlink" title="Java NIO类库之缓冲区"></a>Java NIO类库之缓冲区</h3><p>应用程序与通道的交互主要是进行数据的读取和写入。<strong>为了完成NIO的非阻塞读写操作，NIO为大家准备了第三个重要的组件—— Buffer</strong>。所谓通道的读取，就是将数据从通道读取到缓冲区中；所谓通道的写入，就是将数据从缓冲区写入通道中。缓冲区的使用是面向流进行读写操作的OIO所没有的，也是NIO非阻塞的重要前提和基础之一</p>
<h2 id="详解NIO-Buffer类"><a href="#详解NIO-Buffer类" class="headerlink" title="详解NIO Buffer类"></a>详解NIO Buffer类</h2><p>NIO的Buffer本质上是一个内存块，既可以写入数据，也可以从中读取数据。Java NIO中代表缓冲区的Buffer类是一个抽象类，位于java.nio包中。<br>NIO的Buffer内部是一个内存块（数组），与普通的内存块（Java数组）不同的是：NIO Buffer对象提供了一组比较有效的方法，用来进行写入和读取的交替访问。</p>
<h3 id="NIO-Buffer类的重要属性"><a href="#NIO-Buffer类的重要属性" class="headerlink" title="NIO Buffer类的重要属性"></a>NIO Buffer类的重要属性</h3><p>Buffer类是一个抽象类，对应于Java的主要数据类型。在NIO中，有8种缓冲区类，分别是ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer、MappedByteBuffer。前7种Buffer类型覆盖了能在IO中传输的所有Java基本数据类型，第8种类型是一种专门用于内存映射的ByteBuffer类型。不同的Buffer子类可以操作的数据类型能够通过名称进行判断，比如IntBuffer只能操作Integer类型的对象。实际上，<strong>使用最多的是ByteBuffer（二进制字节缓冲区）类型</strong>。</p>
<p>为了记录读写的状态和位置，Buffer类额外提供了一些重要的属性，其中有三个重要的成员属性：</p>
<ul>
<li>capacity（容量）属性：Buffer类的capacity属性表示内部容量的大小。一旦写入的对象数量超过了capacity，缓冲区就满了，不能再写入了。</li>
<li>position（读写位置）属性：Buffer类的position属性表示当前的位置。position属性的值与缓冲区的读写模式有关。</li>
<li>limit（读写的限制）属性：Buffer类的limit属性表示可以写入或者读取的数据最大上限，其属性值的具体含义也与缓冲区的读写模式有关。<br>除了以上capacity、position、limit三个重要的成员属性之外，Buffer还有一个比较重要的标记属性：mark（标记）属性。该属性的大致作用为：在缓冲区操作过程当中，可以将当前的position值临时存入mark属性中；需要的时候，再从mark中取出暂存的标记值，恢复到position属性中，重新从position位置开始处理。<br><img src="/posts/dd6fbad0/buffer-properties.png" alt="alt text"></li>
</ul>
<h3 id="NIO-Buffer类的重要方法"><a href="#NIO-Buffer类的重要方法" class="headerlink" title="NIO Buffer类的重要方法"></a>NIO Buffer类的重要方法</h3><p>allocate()、put()、get()、flip()、rewind()、mark()、reset()、clear()<br><img src="/posts/dd6fbad0/buffer-method.png" alt="alt text"></p>
<h3 id="使用Buffer类的基本步骤"><a href="#使用Buffer类的基本步骤" class="headerlink" title="使用Buffer类的基本步骤"></a>使用Buffer类的基本步骤</h3><p>总体来说，使用Java NIO Buffer类的基本步骤如下：<br>（1）使用创建子类实例对象的allocate()方法创建一个Buffer类的实例对象。<br>（2）调用put()方法将数据写入缓冲区中。<br>（3）写入完成后，在开始读取数据前调用Buffer.flip()方法，将缓冲区转换为读模式。<br>（4）调用get()方法，可以从缓冲区中读取数据。<br>（5）读取完成后，调用Buffer.clear()方法或Buffer.compact()方法，将缓冲区转换为写模式，可以继续写入。</p>
<h2 id="详解NIO-Channel类"><a href="#详解NIO-Channel类" class="headerlink" title="详解NIO Channel类"></a>详解NIO Channel类</h2><p>着重介绍Java NIO中最为重要的四种Channel：FileChannel、SocketChannel、ServerSocketChannel、DatagramChannel。<br>这四种通道涵盖了文件IO、TCP网络、UDP IO三类基础IO读写操作,对于以上四种通道，说明如下：<br>（1）FileChannel：文件通道，用于文件的数据读写。<br> FileChannel（文件通道）是专门操作文件的通道。通过FileChannel，既可以从一个文件中读取数据，也可以将数据写入文件中。特别申明一下，FileChannel为阻塞模式，不能设置为非阻塞模式。<br>（2）SocketChannel：套接字通道，用于套接字TCP连接的数据读写。<br>（3）ServerSocketChannel：服务器套接字通道（或服务器监听通道），允许我们监听TCP连接请求，为每个监听到的请求创建一个SocketChannel通道。<br>在NIO中，涉及网络连接的通道有两个：一个是SocketChannel，负责连接的数据传输；另一个是ServerSocketChannel，负责连接的监听。其中，NIO中的SocketChannel传输通道与OIO中的Socket类对应，NIO中的ServerSocketChannel监听通道对应于OIO中的ServerSocket类。<br>ServerSocketChannel仅应用于服务端，而SocketChannel同时处于服务端和客户端。所以，对于一个连接，两端都有一个负责传输的SocketChannel。<br>无论是ServerSocketChannel还是SocketChannel，都支持阻塞和非阻塞两种模式。<br>如何进行模式的设置呢？调用configureBlocking()方法，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- socketChannel.configureBlocking(false)设置为非阻塞模式。</span><br><span class="line">- socketChannel.configureBlocking(true)设置为阻塞模式。</span><br></pre></td></tr></table></figure>
<p>在阻塞模式下，SocketChannel的连接、读、写操作都是同步阻塞式的，在效率上与Java OIO面向流的阻塞式读写操作相同。因此，在这里不介绍阻塞模式下通道的具体操作。在非阻塞模式下，通道的操作是异步、高效的，这也是相对于传统OIO的优势所在。<br>（4）DatagramChannel：数据报通道，用于UDP的数据读写。<br>在Java中使用UDP传输数据比TCP更加简单。和socket的TCP不同，UDP不是面向连接的协议。使用UDP时，只要知道服务器的IP和端口就可以直接向对方发送数据。在Java NIO中，使用DatagramChannel来处理UDP的数据传输。</p>
<h2 id="详解NIO-Selector类"><a href="#详解NIO-Selector类" class="headerlink" title="详解NIO Selector类"></a>详解NIO Selector类</h2><h3 id="选择器与注册"><a href="#选择器与注册" class="headerlink" title="选择器与注册"></a>选择器与注册</h3><p><strong>选择器是什么？选择器和通道的关系又是什么？</strong><br>简单地说，选择器的使命是完成IO的多路复用，其主要工作是通道的注册、监听、事件查询。一个通道代表一条连接通路，通过选择器可以同时监控多个通道的IO（输入输出）状况。选择器和通道的关系是监控和被监控的关系。<br>选择器提供了独特的API方法，能够选出（select）所监控的通道已经发生了哪些IO事件，包括读写就绪的IO操作事件。<br>在NIO编程中，一般是一个单线程处理一个选择器，一个选择器可以监控很多通道。所以，通过选择器，一个单线程可以处理数百、数千、数万甚至更多的通道。在极端情况下（数万个连接），只用一个线程就可以处理所有的通道，这样会大量地减少线程之间上下文切换的开销。<br><strong>通道和选择器之间的关联通过register（注册）的方式完成。</strong>调用通道的Channel.register(Selector sel，int ops)方法，可以将通道实例注册到一个选择器中。register方法有两个参数：第一个参数指定通道注册到的选择器实例；第二个参数指定选择器要监控的IO事件类型。<br>可供选择器监控的通道IO事件类型包括以下四种：<br>（1）可读：SelectionKey.OP_READ。<br>（2）可写：SelectionKey.OP_WRITE。<br>（3）连接：SelectionKey.OP_CONNECT。<br>（4）接收：SelectionKey.OP_ACCEPT。<br>以上事件类型常量定义在SelectionKey类中。如果选择器要监控通道的多种事件，可以用“按位或”运算符来实现。例如，同时监控可读和可写IO事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//监控通道的多种事件，用“按位或”运算符来实现 </span><br><span class="line">int key = SelectionKey.OP_READ | SelectionKey.OP_WRITE ;</span><br></pre></td></tr></table></figure>
<p><strong>什么是IO事件？</strong><br>这个概念容易混淆，这里特别说明一下。这里的IO事件不是对通道的IO操作，而是通道处于某个IO操作的就绪状态，表示通道具备执行某个IO操作的条件。例如，某个SocketChannel传输通道如果完成了和对端的三次握手过程，就会发生“连接就绪”（OP_CONNECT）事件；某个ServerSocketChannel服务器连接监听通道，在监听到一个新连接到来时，则会发生“接收就绪”（OP_ACCEPT）事件；一个SocketChannel通道有数据可读，就会发生“读就绪”（OP_READ）事件；一个SocketChannel通道等待数据写入，就会发生“写就绪”（OP_WRITE）事件。</p>
<h3 id="SelectableChannel"><a href="#SelectableChannel" class="headerlink" title="SelectableChannel"></a>SelectableChannel</h3><p>并不是所有的通道都是可以被选择器监控或选择的。例如，FileChannel就不能被选择器复用。判断一个通道能否被选择器监控或选择有一个前提：判断它是否继承了抽象类SelectableChannel（可选择通道），如果是，就可以被选择，否则不能被选择。<br>简单地说，一个通道若能被选择，则必须继承SelectableChannel类。<br>SelectableChannel类是何方神圣呢？它提供了实现通道可选择性所需要的公共方法。Java NIO中所有网络连接socket通道都继承了SelectableChannel类，都是可选择的。FileChannel并没有继承SelectableChannel，因此不是可选择通道。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>通道和选择器的监控关系注册成功后就可以选择就绪事件，具体的选择工作可调用Selector的select()方法来完成。通过select()方法，选择器可以不断地选择通道中所发生操作的就绪状态，返回注册过的那些感兴趣的IO事件。换句话说，一旦在通道中发生了某些IO事件（就绪状态达成），并且是在选择器中注册过的IO事件，就会被选择器选中，并放入SelectionKey（选择键）的集合中。<br>SelectionKey是什么呢？简单地说，<strong>SelectionKey就是那些被选择器选中的IO事件</strong>。前面讲到，一个IO事件发生（就绪状态达成）后，如果之前在选择器中注册过，就会被选择器选中，并放入SelectionKey中；如果之前没有注册过，那么即使发生了IO事件，也不会被选择器选中。SelectionKey和IO的关系可以简单地理解为SelectionKey就是被选中了的IO事件。<br>在实际编程时，SelectionKey的功能是很强大的。通过SelectionKey，不仅可以获得通道的IO事件类型（比如SelectionKey.OP_READ），还可以获得发生IO事件所在的通道。另外，还可以获得选择器实例。</p>
<h3 id="选择器使用流程"><a href="#选择器使用流程" class="headerlink" title="选择器使用流程"></a>选择器使用流程</h3><p>选择器的使用主要有以下三步：<br>（1）获取选择器实例。选择器实例是通过调用静态工厂方法open()来获取的<br>（2）将通道注册到选择器实例。要实现选择器管理通道，需要将通道注册到相应的选择器上<br>（3）选出感兴趣的IO就绪事件（选择键集合）。</p>
<h1 id="《Java高并发核心编程》卷1：第4章鼎鼎大名的Reactor模式"><a href="#《Java高并发核心编程》卷1：第4章鼎鼎大名的Reactor模式" class="headerlink" title="《Java高并发核心编程》卷1：第4章鼎鼎大名的Reactor模式"></a>《Java高并发核心编程》卷1：第4章鼎鼎大名的Reactor模式</h1><h2 id="Reactor模式的重要性"><a href="#Reactor模式的重要性" class="headerlink" title="Reactor模式的重要性"></a>Reactor模式的重要性</h2><p><strong>高性能网络编程</strong>都绕不开Reactor模式。很多著名的服务器软件或者中间件都是基于Reactor模式实现的。例如，“全宇宙有名的、高性能”的Web服务器Nginx就是基于Reactor模式的；如雷贯耳的Redis，作为高性能的缓存服务器之一，也是基于Reactor模式的；目前热门的在开源项目中应用极为广泛的高性能通信中间件Netty，还是基于Reactor模式的。</p>
<h2 id="单线程Reactor模式介绍"><a href="#单线程Reactor模式介绍" class="headerlink" title="单线程Reactor模式介绍"></a>单线程Reactor模式介绍</h2><p><img src="/posts/dd6fbad0/Reactor-single.png" alt="alt text"><br><strong>Reactor模式有点类似事件驱动模式。</strong><br>在事件驱动模式中，当有事件触发时，事件源会将事件分发到Handler（处理器），由Handler负责事件处理。Reactor模式中的反应器角色类似于事件驱动模式中的事件分发器（Dispatcher）角色。<br><strong>Reactor模式由Reactor线程、Handlers处理器两大角色组成</strong>，两大角色的职责分别如下：<br>（1）Reactor线程的职责：负责响应IO事件，当检测到一个IO事件时将其发送给相应的Handler处理器去处理。这里的IO事件就是NIO中选择器查询出来的通道IO事件。<br>（2）Handlers处理器的职责：非阻塞的执行业务处理逻辑。与IO事件（或者选择键）绑定，负责IO事件的处理，完成真正的连接建立、通道的读取、处理业务逻辑、负责将结果写到通道等。</p>
<h3 id="单线程Reactor模式的缺点"><a href="#单线程Reactor模式的缺点" class="headerlink" title="单线程Reactor模式的缺点"></a>单线程Reactor模式的缺点</h3><p>单线程Reactor模式是基于Java的NIO实现的。相对于传统的多线程OIO，Reactor模式不再需要启动成千上万条线程，避免了线程上下文的频繁切换，服务端的效率自然是大大提升了。<br>在单线程Reactor模式中，Reactor和Handler都在同一条线程中执行。这样，带来了一个问题：当其中某个Handler阻塞时，会导致其他所有的Handler都得不到执行。在这种场景下，被阻塞的Handler不仅仅负责输入和输出处理的传输处理器，还包括负责新连接监听的AcceptorHandler处理器，可能导致服务器无响应。这是一个非常严重的缺陷，导致单线程反应器模型在生产场景中使用得比较少。<br>除此之外，目前的服务器都是多核的，单线程Reactor模式模型不能充分利用多核资源。总之，在高性能服务器应用场景中，单线程Reactor模式实际使用的很少。</p>
<h2 id="多线程Reactor模式介绍"><a href="#多线程Reactor模式介绍" class="headerlink" title="多线程Reactor模式介绍"></a>多线程Reactor模式介绍</h2><p>Reactor和Handler挤在单个线程中会造成非常严重的性能缺陷，可以使用多线程来对基础的Reactor模式进行改造和演进。</p>
<h3 id="多线程版本的Reactor模式演进"><a href="#多线程版本的Reactor模式演进" class="headerlink" title="多线程版本的Reactor模式演进"></a>多线程版本的Reactor模式演进</h3><p>多线程Reactor的演进分为两个方面：<br>（1）<strong>升级Handler</strong>。既要使用多线程，又要尽可能高效率，则可以考虑使用线程池。<br>（2）<strong>升级Reactor</strong>。可以考虑引入多个Selector（选择器），提升选择大量通道的能力。<br>总体来说，多线程版本的Reactor模式大致如下：<br>（1）将负责数据传输处理的IOHandler处理器的执行放入独立的线程池中。这样，业务处理线程与负责新连接监听的反应器线程就能相互隔离，避免服务器的连接监听受到阻塞。<br>（2）如果服务器为多核的CPU，可以将反应器线程拆分为多个子反应器（SubReactor）线程；同时，引入多个选择器，并且为每一个SubReactor引入一个线程，一个线程负责一个选择器的事件轮询。这样充分释放了系统资源的能力，也大大提升了反应器管理大量连接或者监听大量传输通道的能力。<br>多线程版本反应器MultiThreadEchoServerReactor的逻辑模型如图所示<br><img src="/posts/dd6fbad0/Reactor-multithread.png" alt="alt text"></p>
<h2 id="Reactor模式的优缺点"><a href="#Reactor模式的优缺点" class="headerlink" title="Reactor模式的优缺点"></a>Reactor模式的优缺点</h2><p>在总结Reactor模式的优点和缺点之前，先看看Reactor模式和其他模式的对比，加强一下对它的理解。<br>（1）<strong>Reactor模式和生产者消费者模式对比</strong><br><strong>二者的相似之处</strong>：在一定程度上，Reactor模式有点类似生产者消费者模式。在生产者消费者模式中，一个或多个生产者将事件加入一个队列中，一个或多个消费者主动从这个队列中拉取（Pull）事件来处理。<br><strong>二者的不同之处</strong>：Reactor模式是基于查询的，没有专门的队列去缓冲存储IO事件，去缓冲存储IO事件，查询到IO事件之后，反应器会根据不同IO选择键（事件）将其分发给对应的Handler来处理。<br>（2）<strong>Reactor模式和观察者模式对比</strong><br><strong>二者的相似之处</strong>：在Reactor模式中，当查询到IO事件后，服务处理程序使用单路&#x2F;多路分发（Dispatch）策略，同步分发这些IO事件。观察者模式（Observer Pattern）也被称作发布&#x2F;订阅模式，它定义了一种依赖关系，让多个观察者同时监听某一个主题（Topic）。这个主题对象在状态发生变化时会通知所有观察者，它们能够执行相应的处理。<br><strong>二者的不同之处</strong>：在Reactor模式中，Handler实例和IO事件（选择键）的订阅关系基本上是一个事件绑定到一个Handler，每一个IO事件（选择键）被查询后，反应器会将事件分发给所绑定的Handler，也就是一个事件只能被一个Handler处理；在观察者模式中，同一时刻、同一主题可以被订阅过的多个观察者处理。<br>最后，总结一下Reactor模式的优点和缺点。作为高性能的IO模式，Reactor模式的优点如下：</p>
<ul>
<li>响应快，虽然同一反应器线程本身是同步的，但是不会被单个连接的IO操作所阻塞。</li>
<li>编程相对简单，最大限度避免了复杂的多线程同步，也避免了多线程各个进程之间切换的开销。</li>
<li>可扩展，可以方便地通过增加反应器线程的个数来充分利用CPU资源。</li>
</ul>
<p>Reactor模式的缺点如下：</p>
<ul>
<li>Reactor模式增加了一定的复杂性，因而有一定的门槛，并且不易于调试。</li>
<li>Reactor模式依赖于操作系统底层的IO多路复用系统调用的支持，如Linux中的epoll系统调用。如果操作系统的底层不支持IO多路复用，Reactor模式不会那么高效。</li>
<li>在同一个Handler业务线程中，如果出现一个长时间的数据读写，就会影响这个反应器中其他通道的IO处理。例如，在大文件传输时，IO操作就会影响其他客户端的响应时间。对于这种操作，还需要进一步对Reactor模式进行改进。</li>
</ul>
<p>&lt;1-4章完&gt;</p>
<h1 id="参考文献或转载相关："><a href="#参考文献或转载相关：" class="headerlink" title="参考文献或转载相关："></a>参考文献或转载相关：</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="/about/">AI-X</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.ai-x.co.uk/posts/dd6fbad0.html">https://www.ai-x.co.uk/posts/dd6fbad0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.ai-x.co.uk" target="_blank">AI-X</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a><a class="post-meta__tags" href="/tags/NIO/">NIO</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/ZooKeeper/">ZooKeeper</a><a class="post-meta__tags" href="/tags/AIO/">AIO</a><a class="post-meta__tags" href="/tags/Feign/">Feign</a><a class="post-meta__tags" href="/tags/Nginx/">Nginx</a><a class="post-meta__tags" href="/tags/LVS/">LVS</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">高并发编程</a></div><div class="post-share"><div class="social-share" data-image="/img/cover-java-high-concurrent.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatGet.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechatGet.jpg"></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/ac7955cc.html" title="自动化运维工具-Ansible技术"><img class="cover" src="/img/cover-ansible.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">自动化运维工具-Ansible技术</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/43482e24.html" title="Java编程之Java高并发核心编程学习之第5-8章Netty技术"><img class="cover" src="/img/cover-java-high-concurrent.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java编程之Java高并发核心编程学习之第5-8章Netty技术</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/57f70b19.html" title="Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习"><img class="cover" src="/img/cover-javacore2.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-19</div><div class="info-item-2">Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/e2d91bb3.html" title="Java编程之Java高并发核心编程学习之第13-15章ZooKeeper-Redis-CrazyIM"><img class="cover" src="/img/cover-java-high-concurrent.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">Java编程之Java高并发核心编程学习之第13-15章ZooKeeper-Redis-CrazyIM</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/43482e24.html" title="Java编程之Java高并发核心编程学习之第5-8章Netty技术"><img class="cover" src="/img/cover-java-high-concurrent.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-27</div><div class="info-item-2">Java编程之Java高并发核心编程学习之第5-8章Netty技术</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/d1ee0423.html" title="Java编程之Java高并发核心编程学习之第9-12章Netty网络实现"><img class="cover" src="/img/cover-java-high-concurrent.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-28</div><div class="info-item-2">Java编程之Java高并发核心编程学习之第9-12章Netty网络实现</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/871c883.html" title="SpringCloud微服务组件架构技术"><img class="cover" src="/img/cover-springcloud.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-25</div><div class="info-item-2">SpringCloud微服务组件架构技术</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a><a class="pagination-related" href="/posts/2851cc61.html" title="LVS负载均衡技术"><img class="cover" src="/img/cover-lvs.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-05</div><div class="info-item-2">LVS负载均衡技术</div></div><div class="info-2"><div class="info-item-1"> </div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/aixlog.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"></div><div class="author-info-name">AI-X</div><div class="author-info-description">AI创造价值</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">128</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">391</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ukhxl"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ukhxl" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:lihengxu.uk@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">AI-X，AI创造价值，关注成长和拓展。本站内若内容或图片失效，请留言反馈。 部分素材来自网络，甚至未注明出处，若不小心影响到您的利益，请联系我们删除。</div></div><div class="card-widget card-widget aside aside-count"><div class="item-headline"><i class="fas fa-hourglass-half"></i><span>人生倒计时</span></div><div class="item-content"><div id="life-progress"></div> <script src="https://cdn-js.moeworld.top/gh/qxdn/life-progress@latest/autoload.min.js"></script></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
          </div>
          <ul class="card-category-list expandBtn" id="aside-cat-list">
            <li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/"><span class="card-category-list-name">AI-X开发</span><span class="card-category-list-count">56</span><i class="fas fa-caret-left expand"></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">前端/浏览器技术</span><span class="card-category-list-count">10</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E5%A4%A7%E6%A8%A1%E5%9E%8B-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"><span class="card-category-list-name">大模型/神经网络</span><span class="card-category-list-count">10</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E6%9C%BA%E5%99%A8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="card-category-list-name">机器/深度学习</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E6%9E%B6%E6%9E%84-%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">架构/框架技术</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E5%BC%80%E5%8F%91/%E7%BC%96%E7%A8%8B-%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">编程/开发技术</span><span class="card-category-list-count">28</span></a></li></ul></li><li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/"><span class="card-category-list-name">AI-X拓展</span><span class="card-category-list-count">19</span><i class="fas fa-caret-left expand"></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/%E4%B8%9A%E8%B4%A2%E7%9B%B8%E5%85%B3/"><span class="card-category-list-name">业财相关</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/%E6%95%B0%E7%90%86%E7%9B%B8%E5%85%B3/"><span class="card-category-list-name">数理相关</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/%E6%98%93%E5%8C%BB%E7%9B%B8%E5%85%B3/"><span class="card-category-list-name">易医相关</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/%E8%8B%B1%E8%AF%AD%E7%9B%B8%E5%85%B3/"><span class="card-category-list-name">英语相关</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E6%8B%93%E5%B1%95/%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%90%A5/"><span class="card-category-list-name">项目运营</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/"><span class="card-category-list-name">AI-X运维</span><span class="card-category-list-count">53</span><i class="fas fa-caret-left expand"></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/Linux-Unix-%E5%BC%80%E6%BA%90%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">Linux/Unix/开源技术</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E5%AE%89%E5%85%A8-%E8%AE%A4%E8%AF%81-%E6%BC%94%E7%BB%83%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">安全/认证/演练技术</span><span class="card-category-list-count">16</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8-%E8%99%9A%E6%8B%9F%E5%8C%96-%E4%BA%91%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">容器/虚拟化/云技术</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E5%BE%AE%E8%BD%AF%E6%8A%80%E6%9C%AF-%E7%BB%88%E7%AB%AF%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">微软技术/终端技术</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"><span class="card-category-list-name">数据处理/存储技术</span><span class="card-category-list-count">9</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89/"><span class="card-category-list-name">网络技术/软件定义</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/AI-X%E8%BF%90%E7%BB%B4/%E8%AF%AD%E9%9F%B3%E7%94%B5%E8%AF%9D-%E8%A7%86%E9%A2%91%E4%BC%9A%E8%AE%AE/"><span class="card-category-list-name">语音电话/视频会议</span><span class="card-category-list-count">3</span></a></li></ul></li>
          </ul></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">《Java高并发核心编程》卷1：内容介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E8%87%AA%E5%BA%8F%E6%91%98%E6%8A%84"><span class="toc-number">2.</span> <span class="toc-text">《Java高并发核心编程》卷1：自序摘抄</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E7%AC%AC1%E7%AB%A0%E9%AB%98%E5%B9%B6%E5%8F%91%E5%BF%85%E5%A4%87%E6%8A%80%E8%83%BD%E6%91%98%E6%8A%84"><span class="toc-number">3.</span> <span class="toc-text">《Java高并发核心编程》卷1：第1章高并发必备技能摘抄</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Netty%E9%AB%98%E5%B9%B6%E5%8F%91%E5%BC%82%E6%AD%A5IO%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">Netty高并发异步IO框架介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E7%94%A8%E4%BE%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">Netty用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.1.2.</span> <span class="toc-text">Netty机制及特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%AB%98%E5%B9%B6%E5%8F%91%E7%BC%93%E5%AD%98%E5%88%A9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Redis高并发缓存利器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">Redis介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%89%B9%E7%82%B9%E5%8F%8A%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.2.</span> <span class="toc-text">Redis特点及场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZooKeeper%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E5%88%A9%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">ZooKeeper高并发分布式利器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ZooKeeper%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E4%BC%98%E5%8A%BF"><span class="toc-number">3.3.1.</span> <span class="toc-text">ZooKeeper的特点及优势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx-RPC%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E9%80%9A%E4%BF%A1-%E8%B0%83%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">3.4.</span> <span class="toc-text">Nginx&#x2F;RPC高并发的通信&#x2F;调用技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QPS%E5%9C%A8%E5%8D%81%E4%B8%87%E7%BA%A7%E7%9A%84Web%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%A4%A7%E8%87%B4%E5%9B%BE"><span class="toc-number">3.4.1.</span> <span class="toc-text">QPS在十万级的Web应用架构大致图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPS%E5%9C%A8%E7%99%BE%E5%8D%83%E4%B8%87%E7%BA%A7%E7%9A%84Web%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E5%A4%A7%E8%87%B4%E5%9B%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">QPS在百千万级的Web应用架构大致图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91RPC%E6%8A%80%E6%9C%AFFeign"><span class="toc-number">3.4.3.</span> <span class="toc-text">微服务的高并发RPC技术Feign</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E7%AC%AC2%E7%AB%A0%E9%AB%98%E5%B9%B6%E5%8F%91IO%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">《Java高并发核心编程》卷1：第2章高并发IO底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E8%AF%BB%E5%86%99%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">4.1.</span> <span class="toc-text">IO读写的基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.1.</span> <span class="toc-text">操作系统的内核空间与用户空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">操作系统的内核态与用户态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%86%85%E6%A0%B8%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.3.</span> <span class="toc-text">操作系统的内核缓冲区与用户进程缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Read-write-socket%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.4.</span> <span class="toc-text">系统调用Read&#x2F;write&#x2F;socket示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">四种主要的IO模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.2.1.</span> <span class="toc-text">同步阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.2.2.</span> <span class="toc-text">同步非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="toc-number">4.2.3.</span> <span class="toc-text">IO多路复用-异步阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="toc-number">4.2.4.</span> <span class="toc-text">异步IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E4%B8%8B%E7%9A%84%E9%AB%98%E5%B9%B6%E5%8F%91%E9%85%8D%E7%BD%AE%E9%99%90%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">Linux下的高并发配置限制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E7%AC%AC3%E7%AB%A0Java-NIO%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">《Java高并发核心编程》卷1：第3章Java NIO核心详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-NIO%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.1.</span> <span class="toc-text">Java NIO组件介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO%E5%92%8COIO%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.1.1.</span> <span class="toc-text">NIO和OIO的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E7%B1%BB%E5%BA%93%E4%B9%8B%E9%80%9A%E9%81%93"><span class="toc-number">5.1.2.</span> <span class="toc-text">Java NIO类库之通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E7%B1%BB%E5%BA%93%E4%B9%8B%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">5.1.3.</span> <span class="toc-text">Java NIO类库之选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-NIO%E7%B1%BB%E5%BA%93%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.1.4.</span> <span class="toc-text">Java NIO类库之缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3NIO-Buffer%E7%B1%BB"><span class="toc-number">5.2.</span> <span class="toc-text">详解NIO Buffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-Buffer%E7%B1%BB%E7%9A%84%E9%87%8D%E8%A6%81%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">NIO Buffer类的重要属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO-Buffer%E7%B1%BB%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.</span> <span class="toc-text">NIO Buffer类的重要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Buffer%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.2.3.</span> <span class="toc-text">使用Buffer类的基本步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3NIO-Channel%E7%B1%BB"><span class="toc-number">5.3.</span> <span class="toc-text">详解NIO Channel类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E8%A7%A3NIO-Selector%E7%B1%BB"><span class="toc-number">5.4.</span> <span class="toc-text">详解NIO Selector类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E%E6%B3%A8%E5%86%8C"><span class="toc-number">5.4.1.</span> <span class="toc-text">选择器与注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectableChannel"><span class="toc-number">5.4.2.</span> <span class="toc-text">SelectableChannel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectionKey"><span class="toc-number">5.4.3.</span> <span class="toc-text">SelectionKey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">5.4.4.</span> <span class="toc-text">选择器使用流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8AJava%E9%AB%98%E5%B9%B6%E5%8F%91%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E3%80%8B%E5%8D%B71%EF%BC%9A%E7%AC%AC4%E7%AB%A0%E9%BC%8E%E9%BC%8E%E5%A4%A7%E5%90%8D%E7%9A%84Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">《Java高并发核心编程》卷1：第4章鼎鼎大名的Reactor模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">6.1.</span> <span class="toc-text">Reactor模式的重要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.2.</span> <span class="toc-text">单线程Reactor模式介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.2.1.</span> <span class="toc-text">单线程Reactor模式的缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8BReactor%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.3.</span> <span class="toc-text">多线程Reactor模式介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%88%E6%9C%AC%E7%9A%84Reactor%E6%A8%A1%E5%BC%8F%E6%BC%94%E8%BF%9B"><span class="toc-number">6.3.1.</span> <span class="toc-text">多线程版本的Reactor模式演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">Reactor模式的优缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%88%96%E8%BD%AC%E8%BD%BD%E7%9B%B8%E5%85%B3%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">参考文献或转载相关：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/e904107c.html" title="Citrix Virtual Apps and Desktops 虚拟化解决方案"><img src="/img/defaultcover-top.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Citrix Virtual Apps and Desktops 虚拟化解决方案"></a><div class="content"><a class="title" href="/posts/e904107c.html" title="Citrix Virtual Apps and Desktops 虚拟化解决方案">Citrix Virtual Apps and Desktops 虚拟化解决方案</a><time datetime="2025-09-21T18:05:38.000Z" title="发表于 2025-09-21 18:05:38">2025-09-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fbf7ef29.html" title="深入揭秘 DeepSeek 核心技术"><img src="/img/cover-deepseekAI.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入揭秘 DeepSeek 核心技术"></a><div class="content"><a class="title" href="/posts/fbf7ef29.html" title="深入揭秘 DeepSeek 核心技术">深入揭秘 DeepSeek 核心技术</a><time datetime="2025-03-08T18:53:17.000Z" title="发表于 2025-03-08 18:53:17">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/36079c3e.html" title="AI大模型九大核心技术总览"><img src="/img/cover-aibigmodels.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AI大模型九大核心技术总览"></a><div class="content"><a class="title" href="/posts/36079c3e.html" title="AI大模型九大核心技术总览">AI大模型九大核心技术总览</a><time datetime="2025-02-25T22:28:11.000Z" title="发表于 2025-02-25 22:28:11">2025-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c3e19837.html" title="跨境支付中绕不开的SWIFT、CIPS、CHIPS"><img src="/img/cover-swift.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="跨境支付中绕不开的SWIFT、CIPS、CHIPS"></a><div class="content"><a class="title" href="/posts/c3e19837.html" title="跨境支付中绕不开的SWIFT、CIPS、CHIPS">跨境支付中绕不开的SWIFT、CIPS、CHIPS</a><time datetime="2025-02-23T09:59:26.000Z" title="发表于 2025-02-23 09:59:26">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/57f70b19.html" title="Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习"><img src="/img/cover-javacore2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习"></a><div class="content"><a class="title" href="/posts/57f70b19.html" title="Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习">Java高并发核心编程 卷2：多线程、锁、JMM、JUC、高并发设计模式学习</a><time datetime="2025-02-19T22:06:59.000Z" title="发表于 2025-02-19 22:06:59">2025-02-19</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/background.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By AI-X</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, Welcome to AI-X! <a href="https://WWW.AI-X.CO.UK/">在积累中成长</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23liprvf5xSJScRbrM',
      clientSecret: '5485e79c27b610b54188d21598eeed4bce81eba4',
      repo: 'ukhxl.github.io',
      owner: 'ukhxl',
      admin: ['ukhxl'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '2001c0a2d7b7bedcb49f4c4dbb5ad3a7'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script>window.newestComments = {
  changeContent: content => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<code>.*?<\/code>/gi, '[代码]') // replace code      
    content = content.replace(/<[^>]+>/g, "") // remove html tag

    if (content.length > 150) {
      content = content.substring(0, 150) + '...'
    }
    return content
  },

  generateHtml: (array, ele) => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class="aside-list-item">'

        if (true && array[i].avatar) {
          const imgAttr = 'src'
          result += `<a href="${array[i].url}" class="thumbnail"><img ${imgAttr}="${array[i].avatar}" alt="${array[i].nick}"></a>`
        }

        result += `<div class="content">
        <a class="comment" href="${array[i].url}" title="${array[i].content}">${array[i].content}</a>
        <div class="name"><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '暂无评论'
    }

    ele.innerHTML = result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh(ele)
  },

  newestCommentInit: (name, getComment) => {
    const $dom = document.querySelector('#card-newest-comments .aside-list')
    if ($dom) {
      const data = btf.saveToLocal.get(name)
      if (data) {
        newestComments.generateHtml(JSON.parse(data), $dom)
      } else {
        getComment($dom)
      }
    }
  },

  run: (name, getComment) => {
    newestComments.newestCommentInit(name, getComment)
    btf.addGlobalFn('pjaxComplete', () => newestComments.newestCommentInit(name, getComment), name)
  }
}</script><script>window.addEventListener('load', () => {
  const keyName = 'github-newest-comments'
  const { changeContent, generateHtml, run } = window.newestComments

  const findTrueUrl = (array, ele) => {
    Promise.all(array.map(item =>
      fetch(item.url).then(resp => resp.json()).then(data => {
        let urlArray = data.body ? data.body.match(/(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?/ig) : []
        if (!Array.isArray(urlArray) || urlArray.length === 0) {
          urlArray = [`${data.html_url}`]
        }
        if (data.user.login === 'utterances-bot') {
          return urlArray.pop()
        } else {
          return urlArray.shift()
        }
      })
    )).then(res => {
        array = array.map((i,index)=> {
          return {
            ...i,
            url: res[index]
          }
        })

        btf.saveToLocal.set(keyName, JSON.stringify(array), 10/(60*24))
        generateHtml(array, ele)
    });
  }

  const getComment = ele => {
    fetch('https://api.github.com/repos/ukhxl/ukhxl.github.io/issues/comments?sort=updated&direction=desc&per_page=6&page=1',{
      "headers": {
        Accept: 'application/vnd.github.v3.html+json'
      }
    })
      .then(response => response.json())
      .then(data => {
        const githubArray = data.map(item => {
          return {
            'avatar': item.user.avatar_url,
            'content': changeContent(item.body_html || item.body),
            'nick': item.user.login,
            'url': item.issue_url,
            'date': item.updated_at
          }
        })
        findTrueUrl(githubArray, ele)
      }).catch(e => {
        console.error(e)
        ele.textContent= "无法获取评论，请确认相关配置是否正确"
      })
  }
  run(keyName, getComment)
})</script><script>let tianliGPT_postSelector = '\#post \#article-container';let tianliGPT_key = 'XUMmGVoE8oT';</script><script src="https://ai.tianli0.top/static/public/tianli_gpt.min.js"></script><script src="/js/customall.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/barry-flynn/hexo-github-calendar/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://github-calendar-api.meta-code.top/api?user=ukhxl";
            var git_color =['#ebedf0', '#a2f7af', '#6ce480', '#54ad63', '#469252', '#31753c', '#1f5f2a', '#13531f', '#084111', '#032b09', '#000000'];
            var git_user ="ukhxl";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log("已挂载hexo-github-calendar https://github.com/Barry-Flynn/hexo-github-calendar");
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X开发/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱 AI-X开发 (56)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X运维/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 AI-X运维 (53)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 AI-X拓展 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X开发/大模型-神经网络/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 AI大模型 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X开发/机器-深度学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 深度学习 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://www.ai-x.co.uk/categories/AI-X开发/编程-开发技术/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎭 编程开发 (28)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://www.ai-x.co.uk/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a69933de.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/cover-java-class.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a69933de.html&quot;);" href="javascript:void(0);" alt="">Java编程之Java Class对象与反射技术</a><div class="blog-slider__text">这篇文章介绍了 Java 编程中 Java Class 对象与反射技术的相关概念。Class 对象是 java.lang.Class 类的对象，保存着每个类型的运行时类型信息，如类名、属性、方法、父类信息等。</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a69933de.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f8303065.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/cover-ipsec.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f8303065.html&quot;);" href="javascript:void(0);" alt="">华为路由器IPSecVPN配置</a><div class="blog-slider__text"> </div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f8303065.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/47c84bfb.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/cover-machinelearning.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-16</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/47c84bfb.html&quot;);" href="javascript:void(0);" alt="">机器学习技术的关键算法</a><div class="blog-slider__text"> </div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/47c84bfb.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/1787a560.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/cover-ciscoesa.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-11-12</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/1787a560.html&quot;);" href="javascript:void(0);" alt="">思科邮件网关ESA策略配置</a><div class="blog-slider__text"> </div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/1787a560.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/975fcf41.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="/img/cover-ise.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-12-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/975fcf41.html&quot;);" href="javascript:void(0);" alt="">思科ISE身份服务引擎-认证与授权系统</a><div class="blog-slider__text"> </div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/975fcf41.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>